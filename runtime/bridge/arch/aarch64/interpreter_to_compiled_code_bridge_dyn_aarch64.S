/*
 * Copyright (c) 2021 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "arch/asm_support.h"

// void InterpreterToCompiledCodeBridgeDyn(
//       const BytecodeInstruction* insn,       x0
//       const Frame *iframe,                   x1
//       const Method*,                         x2
//       ManagedThread* thread)                 x3
.global InterpreterToCompiledCodeBridgeDyn
.type InterpreterToCompiledCodeBridgeDyn, %function
InterpreterToCompiledCodeBridgeDyn:
    CFI_STARTPROC
    CFI_DEF_CFA(sp, 0)

    stp x1, lr, [sp, -16]!
    CFI_ADJUST_CFA_OFFSET(2 * 8)
    CFI_REL_OFFSET(lr, 8)
    stp x19, THREAD_REG, [sp, -32]!
    CFI_ADJUST_CFA_OFFSET(4 * 8)
    CFI_REL_OFFSET(THREAD_REG, 8)
    CFI_REL_OFFSET(x19, 0)
    str fp, [sp, 16]
    CFI_REL_OFFSET(fp, 16)
    add fp, sp, 32
    CFI_DEF_CFA(fp, (2 * 8))
    mov THREAD_REG, x3

    // According to the current frame kind set the bridge type
    ldrb w3, [THREAD_REG, #THREAD_FRAME_KIND]
    tst w3, #0x1
    mov w4, #BYPASS_BRIDGE
    mov w5, #INTERPRETER_TO_COMPILED_CODE_BRIDGE
    csel w3, w4, w5, ne
    str x3, [sp, #24]
    // sp should be 16 bytes aligned.

    // setup regs as follow
    // x9 - frame.vregs, x10 - insn_ptr, x12 - method,
    // x19 - frame, x13, x14 - temp
    add x9, x1, FRAME_VREGS_OFFSET
    mov x10, x0
    mov x12, x2
    mov x19, x1 // save frame to survive the call

    // the following dispatch code expects opcode in w5
    ldrb w5, [x10], 1 // read opcode and advance insn_ptr

    // The file contains code which checks opcode and jumps
    // to the corresponding handler.
    // At the end each handler jumps to .Lload_reg_args label.
    // The file is autogenerated from runtime/templates/bridge_dispatch.S.erb
    // Handlers are distinguished by format and located in the corresponding files with name:
    // handle_call_<format>.S
    // If you get a compilation error that there is no such file it seems
    // new call format was introduced and you have to implement the corresponding handler.
#include "bridge_dispatch_dyn_aarch64.S"

.Linvoke:
    // invoke the entrypoint
    ldr lr, [x12, METHOD_COMPILED_ENTRY_POINT_OFFSET]
    blr lr

    // handle the result
    // setup regs as follow:
    // x0 - result value, x1 - result tag, x19 - frame.acc
    add x19, x19, FRAME_ACC_OFFSET
    stp x0, x1, [x19]

    sub sp, fp, 32
    ldp x19, THREAD_REG, [sp], 48
    CFI_RESTORE(THREAD_REG)
    CFI_RESTORE(x19)
    ldr fp, [sp, -32]
    CFI_RESTORE(fp)
    CFI_DEF_CFA(sp, 0)
    ldr lr, [sp, -8]
    CFI_RESTORE(lr)
    ret
    CFI_ENDPROC

// void InvokeCompiledCodeWithArgArrayDyn(
//       const DecodedTaggedValue* values,      x0
//       uint32_t num_args,                     x1
//       const Frame *iframe,                   x2
//       const Method*,                         x3
//       ManagedThread* thread)                 x4
.global InvokeCompiledCodeWithArgArrayDyn
.type InvokeCompiledCodeWithArgArrayDyn, %function
InvokeCompiledCodeWithArgArrayDyn:
    CFI_STARTPROC
    CFI_DEF_CFA(sp, 0)

    stp x2, lr, [sp, -16]!
    CFI_ADJUST_CFA_OFFSET(2 * 8)
    CFI_REL_OFFSET(lr, 8)
    stp x19, THREAD_REG, [sp, -32]!
    CFI_ADJUST_CFA_OFFSET(4 * 8)
    CFI_REL_OFFSET(THREAD_REG, 8)
    CFI_REL_OFFSET(x19, 0)
    str fp, [sp, 16]
    CFI_REL_OFFSET(fp, 16)
    add fp, sp, 32
    CFI_DEF_CFA(fp, (2 * 8))
    mov THREAD_REG, x4

    // According to the current frame kind set the bridge type
    ldrb w4, [THREAD_REG, #THREAD_FRAME_KIND]
    tst w4, #0x1
    mov w5, #BYPASS_BRIDGE
    mov w6, #INTERPRETER_TO_COMPILED_CODE_BRIDGE
    csel w4, w5, w6, ne
    str x4, [sp, 24]
    // sp should be 16 bytes aligned.

    // setup regs as follow
    // x0 - method, x1 - num_args, x2..x7 - args,
    // x9 - values, w10 - num_args, x11, x12 - temp
    // lr - entrypoint
    ldr lr, [x3, #METHOD_COMPILED_ENTRY_POINT_OFFSET]
    mov x9, x0
    mov x0, x3
    mov w10, w1

    // setup function object
    ldp x2, x3, [x9], FRAME_VREGISTER_SIZE
    // load arg regs
    cbz w10, .Linvoke_
    ldp x4, x5, [x9], FRAME_VREGISTER_SIZE
    sub w10, w10, 1
    cbz w10, .Linvoke_
    ldp x6, x7, [x9], FRAME_VREGISTER_SIZE
    sub w10, w10, 1

    cbz w10, .Linvoke_
    // setup stack args
    // reserve stack space
    // x13 - stack poionter
    sub x13, sp, x10, lsl 4
    mov sp, x13
    // copy arguments to the stack
1:  ldp x11, x12, [x9], FRAME_VREGISTER_SIZE
    stp x11, x12, [x13], FRAME_VREGISTER_SIZE
    sub w10, w10, 1
    cbnz w10, 1b

.Linvoke_:
    // invoke the entrypoint
    blr lr
    
    sub sp, fp, 32
    ldp x19, THREAD_REG, [sp], 48
    CFI_RESTORE(THREAD_REG)
    CFI_RESTORE(x19)
    ldr fp, [sp, -32]
    CFI_RESTORE(fp)
    CFI_DEF_CFA(sp, 0)
    ldr lr, [sp, -8]
    CFI_RESTORE(lr)
    ret
    CFI_ENDPROC
