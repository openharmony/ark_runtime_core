# Copyright (c) 2021-2022 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

definitions:
  - name: java
    template: |
      .language Java

tests:
  - file-name: "initobj.range"
    isa:
      title: Create new object and call initializer
      description: |
        Resolve class type from initializer method_id, allocate memory for an object, initialize its fields with their
        default values (i.e. 0 for primitives and null for objects), call specified initializer and put a reference to
        the newly created object into accumulator. method_id should resolve to an initializer.
        For methods with more arguments range kinds of instruction are to be used, which takes the needed number of
        arguments starting from 'vs' register.
      instructions:
        - sig: initobj.range method_id, v:in:none
          acc: out:ref
          format: [op_v_8_id_16]
    commands:

      - file-name: "invalid_syntax"
        isa:
          verification:
            - method_id_non_static
            - method_id_accessible
            - method_init_obj
        runner-options: [compile-failure]
        description: Check 'initobj.range' instruction with invalid method id.
        header-template: []
        code-template: |
          .record A {
            i32   f32
            A     fA
            i32[] f32Array
            A[]   fAArray
          }
          .function void A.c2(A a0, u32 a1, u32 a2) <ctor> {
            return.void
          }
          .function void A.c1(A a0, u64 a1) <ctor> {
            return.void
          }
          .function void A.c0(A a0) <ctor> {
            return.void
          }
          .function void A.aFunc(A a0) {
            return.void
          }
          .function i32 main() {
          begin:
              initobj.range %s
        check-type: exit-positive
        cases:
          - values:
            - ""
          - values:
            - "label:"
          - values:
            - "begin, v1"
          - values:
            - "{}"
          - values:
            - "}"
          - values:
            - "# comment"
          - values:
            - "null"
          - values:
            - "0, v1"
          - values:
            - "v0, v1"
          - values:
            - "i32, v1"
          - values:
            - i32[], v1
          - values:
            - "\"A\", v1"
          - values:
            - A, v1
          - values:
            - "A.f32, v1"
          - values:
            - "A.fA, v1"
          - values:
            - "A.f32Array, v1"
          - values:
            - "A.fAArray, v1"
          - values:
            - "A[], v1"
          - values:
            - "panda.Object[], v1"
          - values:
            - "aFunc, v1"
          - values:
            - "Object, v1"
          - values:
            - A.c2, v1, v2
          - values:
            - A.c2, a1, a2
          - values:
            - A.c2, 0, 1
          - values:
            - A.c1, a1, a2
          - values:
            - A.c1, v1, v2
          - values:
            - A.c1
          - values:
            - A.c0


      - file-name: "uninitialized_regs_p"
        isa:
          instructions:
            - sig: initobj.range method_id, v:in:none
              acc: out:ref
              format: [op_v_8_id_16]
        runner-options: ['verifier-failure', 'verifier-debug-config']
        tags: [verifier]
        description: Check 'initobj.range' instruction with uninitialized registers in PandaAssembly context.
        header-template: []
        code-template: |
          .record panda.Object <external>
          .record panda.String <external>
          .record R {}
          .function void R.ctor(R a0, %s) <ctor> {
              return.void
          }
          .function i32 main() {
              %s
        check-type: exit-positive
        cases:
          - values:
            # v1 not initialized
            - i32 a1
            - initobj.range R.ctor, v1
          - values:
            # v2 not initialized
            - i64 a1, f64 a2
            - |
              #
                  movi.64 v1, 1
                  initobj.range R.ctor, v1
          - values:
            # v3 not initialized
            - i32[] a1, panda.Object a2, R[] a3
            - |
              #
                  movi v1, 10
                  newarr v1, v1, i32[]
                  mov.null v2
                  initobj.range R.ctor, v1
          - values:
            # v130 not initialized
            - R a1, panda.String a2, f64 a3, panda.Object a4
            - |
              #
                  mov.null v127
                  lda.str "test string"
                  sta.obj v128
                  fmovi.64 v129, 3.14
                  initobj.range R.ctor, v127
          - values:
            # v252, v253, v254, v255 not initialized
            - u1 a1, u8 a2, u16 a3, u32 a4
            - initobj.range R.ctor, v252


      - file-name: "reg_v_invalid"
        isa:
          instructions:
            - sig: initobj.range method_id, v:in:none
              acc: out:ref
              format: [op_v_8_id_16]
        runner-options: [compile-failure]
        description: Check 'initobj.range' instruction with invalid 'v' register numbers.
        header-template: []
        code-template: |
          .record R {}
          .function void R.c(R a0, i32 a1, i32 a2, i32 a3, i32 a4, i32 a5) <ctor> {
              return.void
          }
          #
          .function i32 main() {
              initobj.range R.c, %s
        check-type: exit-positive
        cases:
          - values:
            - v252
            runner-options: ['verifier-failure', 'verifier-debug-config']
            tags: [verifier]
          - values:
            - v255
            runner-options: ['verifier-failure', 'verifier-debug-config']
            tags: [verifier]
          - values:
            - v256
          - values:
            - v65532
          - values:
            - v65535
          - values:
            - v65536


      - file-name: "reg_a_invalid"
        isa:
          instructions:
            - sig: initobj.range method_id, v:in:none
              acc: out:ref
              format: [op_v_8_id_16]
        runner-options: [compile-failure]
        description: Check 'initobj.range' instruction with invalid 'a' register numbers.
        header-template: []
        code-template: |
          .record R {}
          .function void R.c(R a0, i32 a1, i32 a2, i32 a3, i32 a4) <ctor> {
              return.void
          }
          .function void func(i32 a0, i32 a1, i32 a2, i32 a3, i32 a4, i32 a5, i32 a6, i32 a7, i32 a8, i32 a9, i32 a10, i32 a11, i32 a12, i32 a13, i32 a14, i32 a15) {
              initobj.range R.c, %s
              return.void
          }
          #
          .function i32 main() {
              call.range func, v0
        check-type: exit-positive
        cases:
          - values:
            - a13
            runner-options: ['verifier-failure', 'verifier-debug-config']
            tags: [verifier]
          - values:
            - a14
            runner-options: ['verifier-failure', 'verifier-debug-config']
            tags: [verifier]
          - values:
            - a16
          - values:
            - a255
          - values:
            - a256
          - values:
            - a65535
          - values:
            - a65536


      - file-name: "reg_v_valid"
        isa:
          instructions:
            - sig: initobj.range method_id, v:in:none
              acc: out:ref
              format: [op_v_8_id_16]
        description: Check 'initobj.range' instruction with valid 'v' register numbers.
        header-template: []
        code-template: |
          .record R {}
          .function void R.c(R a0, i32 a1, i32 a2, i32 a3, i32 a4, i32 a5) <ctor> {
              return.void
          }
          #
          .function i32 main() {
              movi %s, 100
              movi %s, 200
              movi %s, 300
              movi %s, 400
              movi %s, 500
              lda.null
              initobj.range R.c, %s
              jnez.obj ok
              ldai 1
              return
          ok:
        check-type: exit-positive
        cases:
          - values: [v0, v1, v2, v3, v4, v0]
          - values: [v100, v101, v102, v103, v104, v100]
          - values: [v200, v201, v202, v203, v204, v200]
          - values: [v251, v252, v253, v254, v255, v251]


      - file-name: "reg_a_valid"
        isa:
          instructions:
            - sig: initobj.range method_id, v:in:none
              acc: out:ref
              format: [op_v_8_id_16]
        runner-options: ['verifier-only', 'verifier-debug-config']
        tags: ['verifier']
        description: Check 'initobj.range' instruction with valid 'a' register numbers.
        header-template: []
        code-template: |
          .record R {}
          .function void R.c5(R a0, i32 a1, i32 a2, i32 a3, i32 a4, i32 a5) <ctor> {
              return.void
          }
          .function void R.c16(R a0, i32 a1, i32 a2, i32 a3, i32 a4, i32 a5, i32 a6, i32 a7, i32 a8, i32 a9, i32 a10, i32 a11, i32 a12, i32 a13, i32 a14, i32 a15) <ctor> {
              return.void
          }
          .function void func(i32 a0, i32 a1, i32 a2, i32 a3, i32 a4, i32 a5, i32 a6, i32 a7, i32 a8, i32 a9, i32 a10, i32 a11, i32 a12, i32 a13, i32 a14, i32 a15) {
              initobj.range R.c5, a0
              initobj.range R.c5, a11
              initobj.range R.c16, a0
              return.void
          }
          #
          .function i32 main() {
              movi v0, 0
              movi v1, 1
              movi v2, 2
              movi v3, 3
              movi v4, 4
              movi v5, 5
              movi v6, 6
              movi v7, 7
              movi v8, 8
              movi v9, 9
              movi v10, 10
              movi v11, 11
              movi v12, 12
              movi v13, 13
              movi v14, 14
              movi v15, 15
              call.range func, v0
        check-type: exit-positive


      - file-name: "invalid_ctor_p"
        isa:
          verification:
            - method_id_non_static
            - method_id_accessible
            - method_init_obj
        runner-options: ['verifier-failure', 'verifier-debug-config']
        tags: [verifier]
        description: Check 'initobj.range' instruction with invalid initializer in PandaAssembly context.
        header-template: []
        code-template: |
          .record R {}
          %s
          .function i32 main() {
              %s
        check-type: exit-positive
        cases:
          # static functions
          - values:
            - ""
            - |
              #
                  movi v1, 1
                  initobj.range main, v1
            bugid: ['3585']
            ignore: true
          - values:
            - |
              .function void R.cctor() <cctor> {
                  return.void
              }
            - |
              #
                  movi v255, 0
                  initobj.range R.cctor, v255
            bugid: ['3585']
            ignore: true
          - values:
            - |
              .function void R.cctor(i32 a0) <cctor> {
                  return.void
              }
            - |
              #
                  movi v1, 1
                  initobj.range R.cctor, v1
          - values:
            - |
              .function void R.ctor() <ctor> {
                  return.void
              }
              .function void R.cctor(R a0, i32 a1) <cctor> {
                  return.void
              }
            - |
              #
                  initobj R.ctor
                  sta.obj v0
                  movi v1, 1
                  initobj.range R.cctor, v0
          - values:
            - |
              .function void R.cctor(R a0, i32 a1) <cctor> {
                  return.void
              }
            - |
              #
                  movi v1, 1
                  initobj.range R.cctor, v1
            bugid: ['3585']
            ignore: true
          - values:
            - |
              .function void R.statFunc() <static> {
                  return.void
              }
            - |
              #
                  movi v1, 0
                  initobj.range R.statFunc, v1
            bugid: ['3585']
            ignore: true
          - values:
            - |
              .function void R.statFunc(i32 a0) <static> {
                  return.void
              }
            - |
              #
                  movi v1, 0
                  initobj.range R.statFunc, v1
          - values:
            - |
              .function void R.ctor() <ctor> {
                  return.void
              }
              .function void R.statFunc(R a0, i32 a1) <static> {
                  return.void
              }
            - |
              #
                  initobj R.ctor
                  sta.obj v0
                  movi v1, 0
                  initobj.range R.statFunc, v0
          - values:
            - |
              .function void R.statFunc(R a0, i32 a1) <static> {
                  return.void
              }
            - |
              #
                  movi v1, 0
                  initobj.range R.statFunc, v1
            bugid: ['3585']
            ignore: true
          # virtual functions, not initializers
          - values:
            - |
              .function void R.virtFunc(R a0, i32 a1) {
                  return.void
              }
            - |
              #
                  movi v7, 0
                  initobj.range R.virtFunc, v7
            bugid: ['3585']
            ignore: true
          - values:
            - |
              .function void R.ctor() <ctor> {
                  return.void
              }
              .function void R.virtFunc(R a0, i32 a1) {
                  return.void
              }
            - |
              #
                  initobj R.ctor                 # should be ok
                  sta.obj v0
                  movi v1, 1
                  initobj.range R.virtFunc, v0   # should fail
            bugid: ['3585']
            ignore: true
          - values:
            - |
              .record panda.NullPointerException <external>
              .record panda.String <external>
              .function panda.String panda.NullPointerException.getMessage(panda.NullPointerException a0) <external>
            - |
              #
                  mov.null v1
                  initobj.range panda.NullPointerException.getMessage, v1
            bugid: ['3585']
            ignore: true
          - values:
            - |
              .function void R.ctor() <ctor> {
                  return.void
              }
              .record panda.NullPointerException <external>
              .record panda.String <external>
              .record panda.Object <external>
              .function void panda.NullPointerException.ctor(panda.NullPointerException a0, panda.String a1, panda.Object a2) <external, ctor>
              .function panda.String panda.NullPointerException.getMessage(panda.NullPointerException a0) <external>
            - |
              #
                  lda.str "message"
                  sta.obj v1
                  initobj R.ctor                                            # should be ok
                  sta.obj v2
                  initobj.range panda.NullPointerException.ctor, v1         # should be ok
                  sta.obj v0
                  initobj.range panda.NullPointerException.getMessage, v0   # should fail
            bugid: ['3585']
            ignore: true
          # inaccessible methods
          - values:
            - .function void R.extFunc(R a0) <external>
            - |
              #
                  mov.null v1
                  initobj.range R.extFunc, v1
            bugid: ['3585']
            ignore: true
          - values:
            - .function void R.extFunc(R a0, R a1) <external>
            - |
              #
                  mov.null v1
                  initobj.range R.extFunc, v1
            bugid: ['3585']
            ignore: true
          - values:
            - .function void R.nativeFunc(R a0) <native>
            - |
              #
                  mov.null v1
                  initobj.range R.nativeFunc, v1
            bugid: ['3585']
            ignore: true
          - values:
            - .function void R.nativeFunc(R a0, R a1) <native>
            - |
              #
                  mov.null v1
                  initobj.range R.nativeFunc, v1
            bugid: ['3585']
            ignore: true
          - values:
            - .function void R.noimplFunc(R a0) <noimpl>
            - |
              #
                  mov.null v1
                  initobj.range R.noimplFunc, v1
            bugid: ['3585']
            ignore: true
          - values:
            - .function void R.noimplFunc(R a0, R a1) <noimpl>
            - |
              #
                  mov.null v1
                  initobj.range R.noimplFunc, v1
            bugid: ['3585']
            ignore: true
          # ctor without return
          - values:
            - .function void R.ctorNoReturn(R a0) <ctor> {}
            - |
              #
                  mov.null v1
                  initobj.range R.ctorNoReturn, v1
            bugid: ['3585']
            ignore: true
          - values:
            - .function void R.ctorNoReturn(R a0, R a1) <ctor> {}
            - |
              #
                  mov.null v1
                  initobj.range R.ctorNoReturn, v1
            bugid: ['3585']
            ignore: true


      - file-name: "incompatible_args_p"
        isa:
          verification:
            - compatible_arguments
        runner-options: ['verifier-failure', 'verifier-debug-config']
        tags: [verifier]
        description: Check 'initobj.range' instruction with initializer called with incompatible arguments in PandaAssembly context.
        header-template: []
        code-template: |
          .record panda.Object <external>
          .record panda.Class <external>
          .record panda.String <external>
          .record R {}
          .function void R.constructor(R a0, %s a1) <ctor> {
              return.void
          }

          .function i32 main() {
              *s
              initobj.range R.constructor, v1
        check-type: exit-positive
        template-cases:
          - values:
            - u1
            exclude: [i32]
          - values:
            - u8
            exclude: [i32]
          - values:
            - i8
            exclude: [i32]
          - values:
            - u16
            exclude: [i32]
          - values:
            - i16
            exclude: [i32]
          - values:
            - u32
            exclude: [i32]
          - values:
            - u64
            exclude: [i64]
          - values:
            - f32
            exclude: [f64]
          - values:
            - u32[]
            exclude: [u32a, nul]
          - values:
            - u64[]
            exclude: [u64a, nul]
          - values:
            - f32[]
            exclude: [f32a, nul]
          - values:
            - u32[][]
            exclude: [u32aa, nul]
          - values:
            - u64[][]
            exclude: [u64aa, nul]
          - values:
            - f32[][]
            exclude: [f32aa, nul]
          - values:
            - R
            exclude: [nul]
          - values:
            - panda.String
            exclude: [str, nul]
          - values:
            - panda.Class
            exclude: [typ, nul]
          - values:
            - panda.Object
            exclude: [u32a, u64a, f32a, u32aa, u64aa, f32aa, str, typ, ra, stra, typa, obja, raa, straa, typaa, objaa, nul]
          - values:
            - R[]
            exclude: [ra, nul]
          - values:
            - panda.String[]
            exclude: [stra, nul]
          - values:
            - panda.Class[]
            exclude: [typa, nul]
          - values:
            - panda.Object[]
            exclude: [obja, u32aa, u64aa, f32aa, ra, stra, typa, raa, straa, typaa, objaa, nul]
          - values:
            - R[][]
            exclude: [raa, nul]
          - values:
            - panda.String[][]
            exclude: [straa, nul]
          - values:
            - panda.Class[][]
            exclude: [typaa, nul]
          - values:
            - panda.Object[][]
            exclude: [objaa, raa, straa, typaa, nul]
        cases:
          - values:
            - movi v1, 1
            id: i32
          - values:
            - movi.64 v1, 1
            id: i64
          - values:
            - fmovi.64 v1, 1.0
            id: f64
          - values:
            - |
              #
                  movi v1, 10
                  newarr v1, v1, u32[]
            id: u32a
          - values:
            - |
              #
                  movi v1, 10
                  newarr v1, v1, u64[]
            id: u64a
          - values:
            - |
              #
                  movi v1, 10
                  newarr v1, v1, f32[]
            id: f32a
          - values:
            - |
              #
                  movi v1, 10
                  newarr v1, v1, u32[][]
            id: u32aa
          - values:
            - |
              #
                  movi v1, 10
                  newarr v1, v1, u64[][]
            id: u64aa
          - values:
            - |
              #
                  movi v1, 10
                  newarr v1, v1, f32[][]
            id: f32aa
          - values:
            - |
              #
                  lda.str "test message"
                  sta.obj v1
            id: str
          - values:
            - |
              #
                  lda.type R
                  sta.obj v1
            id: typ
          - values:
            - |
              #
                  movi v1, 10
                  newarr v1, v1, R[]
            id: ra
          - values:
            - |
              #
                  movi v1, 10
                  newarr v1, v1, panda.String[]
            id: stra
          - values:
            - |
              #
                  movi v1, 10
                  newarr v1, v1, panda.Class[]
            id: typa
          - values:
            - |
              #
                  movi v1, 10
                  newarr v1, v1, panda.Object[]
            id: obja
          - values:
            - |
              #
                  movi v1, 10
                  newarr v1, v1, R[][]
            id: raa
          - values:
            - |
              #
                  movi v1, 10
                  newarr v1, v1, panda.String[][]
            id: straa
          - values:
            - |
              #
                  movi v1, 10
                  newarr v1, v1, panda.Class[][]
            id: typaa
          - values:
            - |
              #
                  movi v1, 10
                  newarr v1, v1, panda.Object[][]
            id: objaa
          - values:
            - mov.null v1
            id: nul


      - file-name: "compatible_primitive_args_p"
        isa:
          verification:
            - compatible_arguments
        runner-options: ['verifier-only', 'verifier-debug-config']
        tags: [verifier]
        description: Check 'initobj.range' instruction with initializer called with compatible primitive arguments in PandaAssembly context.
        header-template: []
        code-template: |
          .record R {}
          .function void R.constructor(R a0, %s a1) <ctor> {
              return.void
          }
          .function i32 main() {
              %s
              initobj.range R.constructor, v1
        check-type: exit-positive
        cases:
          - values:
            - u1
            - movi v1, 1
          - values:
            - u8
            - movi v1, 1
          - values:
            - i8
            - movi v1, 1
          - values:
            - u16
            - movi v1, 1
          - values:
            - i16
            - movi v1, 1
          - values:
            - u32
            - movi v1, 1
          - values:
            - i32
            - movi v1, 1
          - values:
            - i64
            - movi.64 v1, 1
          - values:
            - u64
            - movi.64 v1, 1
          - values:
            - f32
            - fmovi.64 v1, 1.1
          - values:
            - f64
            - fmovi.64 v1, 1.1


      - file-name: "compatible_prim_array_args_p"
        isa:
          verification:
            - compatible_arguments
        runner-options: ['verifier-only', 'verifier-debug-config']
        tags: [verifier]
        description: Check 'initobj.range' instruction with initializer called with compatible primitive array arguments in PandaAssembly context.
        header-template: []
        code-template: |
          .record R {}
          .function void R.constructor(R a0, %s a1) <ctor> {
              return.void
          }
          .function i32 main() {
              movi v0, 10
              newarr v1, v0, %s
              initobj.range R.constructor, v1
        check-type: exit-positive
        cases:
          - values:
            - "u1[]"
            - "u1[]"
          - values:
            - "u8[]"
            - "u8[]"
          - values:
            - "i8[]"
            - "i8[]"
          - values:
            - "u16[]"
            - "u16[]"
          - values:
            - "i16[]"
            - "i16[]"
          - values:
            - "u32[]"
            - "u32[]"
          - values:
            - "i32[]"
            - "i32[]"
          - values:
            - "u64[]"
            - "u64[]"
          - values:
            - "i64[]"
            - "i64[]"
          - values:
            - "f32[]"
            - "f32[]"
          - values:
            - "f64[]"
            - "f64[]"
          - values:
            - "u1[][]"
            - "u1[][]"
          - values:
            - "u8[][]"
            - "u8[][]"
          - values:
            - "i8[][]"
            - "i8[][]"
          - values:
            - "u16[][]"
            - "u16[][]"
          - values:
            - "i16[][]"
            - "i16[][]"
          - values:
            - "u32[][]"
            - "u32[][]"
          - values:
            - "i32[][]"
            - "i32[][]"
          - values:
            - "u64[][]"
            - "u64[][]"
          - values:
            - "i64[][]"
            - "i64[][]"
          - values:
            - "f32[][]"
            - "f32[][]"
          - values:
            - "f64[][]"
            - "f64[][]"


      - file-name: "compatible_obj_args_p"
        isa:
          verification:
            - compatible_arguments
        runner-options: ['verifier-only', 'verifier-debug-config']
        tags: [verifier]
        description: Check 'initobj.range' instruction with initializer called with compatible object arguments in PandaAssembly context.
        header-template: []
        code-template: |
          .record panda.Object <external>
          .record panda.Class <external>
          .record panda.String <external>
          .record Q {}
          .function void Q.ctor(Q a0, u8 a1) <ctor> {
              return.void
          }
          .record R {}
          .function void R.constructor(R a0, %s a1) <ctor> {
              return.void
          }
          .function i32 main() {
              %s
              initobj.range R.constructor, v1
        check-type: exit-positive
        cases:
          # Object of type O is instance of type T if O is the same as T ...
          - values:
            - Q
            - |
              #
                  movi v1, 1
                  initobj.range Q.ctor, v1
                  sta.obj v1
          - values:
            - panda.String
            - |
              #
                  lda.str "test"
                  sta.obj v1
          - values:
            - panda.Class
            - |
              #
                  lda.type Q
                  sta.obj v1
          # ... or is subtype of T
          - values:
            - panda.Object
            - |
              #
                  movi v1, 1
                  initobj.range Q.ctor, v1
                  sta.obj v1
          - values:
            - panda.Object
            - |
              #
                  lda.str "test"
                  sta.obj v1
          - values:
            - panda.Object
            - |
              #
                  lda.type Q
                  sta.obj v1
            id: cls
            bugid: ["3594"]
            ignore: true
          # For arrays T should be a root type in type hierarchy ...
          - values:
            - panda.Object
            - |
              #
                  movi v0, 10
                  newarr v1, v0, i32[]
          - values:
            - panda.Object
            - |
              #
                  movi v0, 10
                  newarr v1, v0, f64[][]
          - values:
            - panda.Object
            - |
              #
                  movi v0, 10
                  newarr v1, v0, Q[]
          - values:
            - panda.Object
            - |
              #
                  movi v0, 10
                  newarr v1, v0, panda.Object[]
          - values:
            - panda.Object
            - |
              #
                  movi v0, 10
                  newarr v1, v0, panda.String[]
          - values:
            - panda.Object
            - |
              #
                  movi v0, 10
                  newarr v1, v0, panda.Class[]


      - file-name: "compatible_obj_array_args_p"
        isa:
          verification:
            - compatible_arguments
        runner-options: ['verifier-only', 'verifier-debug-config']
        tags: [verifier]
        description: Check 'initobj.range' instruction with initializer called with compatible object array arguments in PandaAssembly context.
        header-template: []
        code-template: |
          .record panda.Object <external>
          .record panda.Class <external>
          .record panda.String <external>
          .record Q {}
          .record R {}
          .function void R.constructor(R a0, %s a1) <ctor> {
              return.void
          }
          .function i32 main() {
              movi v0, 10
              newarr v1, v0, %s
              initobj.range R.constructor, v1
        check-type: exit-positive
        cases:
          # T is such array that O array elements are the same as T array elements
          - values:
            - Q[]
            - Q[]
          - values:
            - Q[][]
            - Q[][]
          - values:
            - "panda.Object[]"
            - "panda.Object[]"
          - values:
            - "panda.Object[][]"
            - "panda.Object[][]"
          - values:
            - panda.String[]
            - panda.String[]
          - values:
            - panda.String[][]
            - panda.String[][]
          - values:
            - panda.Class[]
            - panda.Class[]
          - values:
            - panda.Class[][]
            - panda.Class[][]
          # T is such array that O array elements are subtypes of T array elements
          - values:
            - "panda.Object[]"
            - "panda.Object[][]"
            bugid: ["3608"]
            ignore: true
          - values:
            - "panda.Object[]"
            - Q[]
            bugid: ["3608"]
            ignore: true
          - values:
            - "panda.Object[]"
            - Q[][]
            bugid: ["3608"]
            ignore: true
          - values:
            - "panda.Object[]"
            - panda.Class[]
            bugid: ["3608"]
            ignore: true
          - values:
            - "panda.Object[]"
            - panda.Class[][]
            bugid: ["3608"]
            ignore: true
          - values:
            - "panda.Object[]"
            - panda.String[]
            bugid: ["3608"]
            ignore: true
          - values:
            - "panda.Object[]"
            - panda.String[][]
            bugid: ["3608"]
            ignore: true
          - values:
            - "panda.Object[]"
            - i32[][]
            bugid: ["3608"]
            ignore: true
          - values:
            - "panda.Object[]"
            - f64[][][]
            bugid: ["3608"]
            ignore: true
          # inherited types from panda.Object[][]
          - values:
            - "panda.Object[][]"
            - panda.Object[][][]
            bugid: ["3608"]
            ignore: true
          - values:
            - "panda.Object[][]"
            - panda.Class[][]
            bugid: ["3608"]
            ignore: true
          - values:
            - "panda.Object[][]"
            - panda.Class[][][]
            bugid: ["3608"]
            ignore: true
          - values:
            - "panda.Object[][]"
            - i32[][][]
            bugid: ["3608"]
            ignore: true
          - values:
            - "panda.Object[][]"
            - f64[][][][]
            bugid: ["3608"]
            ignore: true


      - file-name: "compatible_obj_null_args_p"
        isa:
          verification:
            - compatible_arguments
        runner-options: ['verifier-only', 'verifier-debug-config']
        tags: [verifier]
        description: Check 'initobj.range' instruction with initializer called with null object ref in PandaAssembly context.
        header-template: []
        code-template: |
          .record panda.Object <external>
          .record panda.Class <external>
          .record panda.String <external>
          .record Q {}
          .record R {}
          .function void R.constructor(R a0, %s a1) <ctor> {
              return.void
          }
          .function i32 main() {
              mov.null v1
              initobj.range R.constructor, v1
        check-type: exit-positive
        cases:
          - values: ["i32[]"]
          - values: ["f64[][]"]
          - values: ["panda.Object"]
          - values: ["panda.Object[]"]
          - values: ["panda.Object[][]"]
          - values: ["Q"]
          - values: ["Q[][]"]
          - values: ["panda.String"]
          - values: ["panda.String[]"]
          - values: ["panda.Class"]
          - values: ["panda.Class[]"]


      - file-name: "valid_instance_p"
        isa:
          description: |
            Resolve class type from initializer method_id, allocate memory for an object, initialize its fields with their
            default values (i.e. 0 for primitives and null for objects), call specified initializer and put a reference to
            the newly created object into accumulator. method_id should resolve to an initializer.
        description: Check 'initobj.range' with valid method id creates expected instance type in PandaAssembly context.
        header-template: []
        code-template: |
          .record panda.Object <external>
          .record panda.String <external>
          .record R {}
          .function void R.ctor1(R a0, i32 a1) <ctor> {
            return.void
          }
          .function R[] R.ctor1x(R a0, i32 a1) <ctor> {
            movi v0, 10
            newarr v0, v0, R[]
            lda.obj v0
            return.obj
          }
          .function void R.ctor2(R a0, i16 a1, R a2) <ctor> {
            return.void
          }
          .function R R.ctor2x(R a0, i16 a1, R a2) <ctor> {
            lda.null
            return.obj
          }
          .function void R.ctor3(R a0, i32[] a1, R[] a2, i8 a3) <ctor> {
            return.void
          }
          .function panda.Object[] R.ctor3x(R a0, i32[] a1, R[] a2, i8 a3) <ctor> {
            movi v0, 10
            newarr v0, v0, panda.Object[]
            lda.obj v0
            return.obj
          }
          .function void R.ctor4(R a0, R[][] a1, R[] a2, i32 a3, f64 a4) <ctor> {
            return.void
          }
          .record panda.NullPointerException <external>
          .function void panda.NullPointerException.ctor(panda.NullPointerException a0, panda.String a1, panda.Object a2) <external, ctor>

          .function i32 main() {
          # sample data to put in arguments: v1 - v7
              movi v1, 1
              mov.null v2
              movi v0, 10
              newarr v3, v0, R[]
              movi v4, 0x7f
              fmovi.64 v5, 3.14
              lda.str "exception message"
              sta.obj v6
              mov.null v7

          # create the object
              initobj.range %s
              jnez.obj chk1
              ldai 1
              return
          chk1:
              sta.obj v0
              isinstance %s
              jeq v1, chk2
              ldai 2
              return
          chk2:
              lda.obj v0
              isinstance panda.Object
              jeq v1, ok
              ldai 3
              return
          ok:
        check-type: exit-positive
        cases:
          - values:
            - R.ctor1, v1
            - R
            tags: ['tsan']
          - values:
            - R.ctor1x, v1
            - R
          - values:
            - R.ctor2, v1
            - R
          - values:
            - R.ctor2x, v1
            - R
          - values:
            - R.ctor3, v2
            - R
          - values:
            - R.ctor3x, v2
            - R
            tags: ['tsan']
          - values:
            - R.ctor4, v2
            - R
          - values:
            - panda.NullPointerException.ctor, v6
            - panda.NullPointerException


      - file-name: "check_args_num_p"
        isa:
          instructions:
            - sig: initobj.range method_id, v:in:none
              acc: out:ref
              format: [op_v_8_id_16]
        description: Check 'initobj.range' constructor behavior with various number of arguments in PandaAssembly context.
        header-template: []
        code-template: |
          .record R {
              i32      f1
              i32      f2
              i32      f3
              i32      f4
              i32      f5
          }
          .function void R.ctor1(R a0, i32 a1) <ctor> {
              lda a1
              stobj a0, R.f1
              return.void
          }
          .function void R.ctor2(R a0, i32 a1, i32 a2) <ctor> {
              lda a1
              stobj a0, R.f1
              lda a2
              stobj a0, R.f2
              return.void
          }
          .function void R.ctor3(R a0, i32 a1, i32 a2, i32 a3) <ctor> {
              lda a1
              stobj a0, R.f1
              lda a2
              stobj a0, R.f2
              lda a3
              stobj a0, R.f3
              return.void
          }
          .function void R.ctor4(R a0, i32 a1, i32 a2, i32 a3, i32 a4) <ctor> {
              lda a1
              stobj a0, R.f1
              lda a2
              stobj a0, R.f2
              lda a3
              stobj a0, R.f3
              lda a4
              stobj a0, R.f4
              return.void
          }
          .function void R.ctor5(R a0, i32 a1, i32 a2, i32 a3, i32 a4, i32 a5) <ctor> {
              lda a1
              stobj a0, R.f1
              lda a2
              stobj a0, R.f2
              lda a3
              stobj a0, R.f3
              lda a4
              stobj a0, R.f4
              lda a5
              stobj a0, R.f5
              return.void
          }
          .function i32 main() {
          # sample data to put in args
              movi v1, 10
              movi v2, 20
              movi v3, 30
              movi v4, 40
              movi v5, 50
              movi v6, 60
              movi v7, 70
              movi v8, 80
              movi v9, 90
          # create the object
              %s
              sta.obj v0
          lab1:
              ldobj v0, R.f1
              movi v7, %s
              jeq v7, lab2
              ldai 1
              return
          lab2:
              ldobj v0, R.f2
              movi v7, %s
              jeq v7, lab3
              ldai 2
              return
          lab3:
              ldobj v0, R.f3
              movi v7, %s
              jeq v7, lab4
              ldai 3
              return
          lab4:
              ldobj v0, R.f4
              movi v7, %s
              jeq v7, lab5
              ldai 4
              return
          lab5:
              ldobj v0, R.f5
              movi v7, %s
              jeq v7, ok
              ldai 4
              return
          ok:
        check-type: exit-positive
        cases:
          - values: ["initobj.range R.ctor1, v1", 10, 0, 0, 0, 0]
          - values: ["initobj.range R.ctor2, v2", 20, 30, 0, 0, 0]
          - values: ["initobj.range R.ctor3, v3", 30, 40, 50, 0, 0]
          - values: ["initobj.range R.ctor4, v4", 40, 50, 60, 70, 0]
          - values: ["initobj.range R.ctor5, v5", 50, 60, 70, 80, 90]


      - file-name: "check_last_regs_p"
        isa:
          instructions:
            - sig: initobj.range method_id, v:in:none
              acc: out:ref
              format: [op_v_8_id_16]
        description: Check 'initobj.range' constructor with last of 255 arguments in PandaAssembly context.
        header-template: []
        code-template: |
          .record Z {
          %s
          }
          .function void Z.ctor(Z a0%s) <ctor> {
          %s
              return.void
          }
          .function i32 main() {
          %s
              initobj.range Z.ctor, v%s
              sta.obj v0
          %s
          lbl256:
        check-type: exit-positive
        cases:
          - values:
            - "#{[*1..10].map do |i| \"    i32   f#{i}\\n\" end .join}"
            - "#{[*1..10].map do |i| \", i32 a#{i}\" end .join}"
            - "#{[*1..10].map do |i| \"    lda a#{i}\\n    stobj a0, Z.f#{i}\\n\" end .join}"
            - "#{[*1..10].map do |i| \"    movi v#{i+245}, #{i}\\n\" end .join}"
            - "246"
            - "#{[*1..10].map do |i| \"lbl#{i+245}:\\n    ldobj v0, Z.f#{i}\\n    jeq v#{i+245}, lbl#{i+246}\\n    ldai #{i}\\n    return\\n\" end .join}"
          - values:
            - "#{[*1..254].map do |i| \"    i32   f#{i}\\n\" end .join}"
            - "#{[*1..254].map do |i| \", i32 a#{i}\" end .join}"
            - "#{[*1..254].map do |i| \"    lda a#{i}\\n    stobj a0, Z.f#{i}\\n\" end .join}"
            - "#{[*1..254].map do |i| \"    movi v#{i+1}, #{i}\\n\" end .join}"
            - "2"
            - "#{[*1..254].map do |i| \"lbl#{i+1}:\\n    ldobj v0, Z.f#{i}\\n    jeq v#{i+1}, lbl#{i+2}\\n    ldai #{i}\\n    return\\n\" end .join}"
            bugid: ['3796']
          - values:
            - "#{[*1..255].map do |i| \"    i32   f#{i}\\n\" end .join}"
            - "#{[*1..255].map do |i| \", i32 a#{i}\" end .join}"
            - "#{[*1..255].map do |i| \"    lda a#{i}\\n    stobj a0, Z.f#{i}\\n\" end .join}"
            - "#{[*1..255].map do |i| \"    movi v#{i}, #{i}\\n\" end .join}"
            - "1"
            - "#{[*1..255].map do |i| \"lbl#{i}:\\n    ldobj v0, Z.f#{i}\\n    jeq v#{i}, lbl#{i+1}\\n    ldai #{i}\\n    return\\n\" end .join}"
            bugid: ['3855']
            ignore: true


      - file-name: "check_all_32bit_types_p"
        isa:
          instructions:
            - sig: initobj.range method_id, v:in:none
              acc: out:ref
              format: [op_v_8_id_16]
        description: Check 'initobj.range' constructor behavior with primitive 32bit argument types in PandaAssembly context.
        header-template: []
        code-template: |
          .record Z {
              %s    f
          }
          .function void Z.ctor1(Z a0, i32 a1) <ctor> {
              return.void
          }
          .function void Z.ctor2(Z a0, %s a1) <ctor> {
              lda a1
              stobj a0, Z.f
              return.void
          }
          .function i32 main() {
              movi v1, -1
              initobj.range Z.ctor1, v1
              sta.obj v0
              ldobj v0, Z.f
              jeqz chk2
              ldai 1
              return
          chk2:
              movi v1, %s
              initobj.range Z.ctor2, v1
              sta.obj v0
              ldobj v0, Z.f
              %s
              jeqz ok
              ldai 2
              return
          ok:
        check-type: exit-positive
        cases:
          - values:
            - u1
            - u1
            - 1
            - |
              #
                  jne v1, exit_failure
                  ldai 0
                  return
              exit_failure:
                  ldai 1
                  return
          - values:
            - u1
            - u1
            - 0
            - |
              #
                  jne v1, exit_failure
                  ldai 0
                  return
              exit_failure:
                  ldai 1
                  return
          - values: [u8, u8, 0, ucmp v1]
          - values: [u8, u8, 0x000000ff, ucmp v1]
          - values: [u8, u8, 0x0000005a, ucmp v1]
          - values:
            - i8
            - i8
            - 0
            - |
              #
                  jne v1, exit_failure
                  ldai 0
                  return
              exit_failure:
                  ldai 1
                  return
          - values:
            - i8
            - i8
            - 0xffffffff
            - |
              #
                  jne v1, exit_failure
                  ldai 0
                  return
              exit_failure:
                  ldai 1
                  return
          - values:
            - i8
            - i8
            - 0x0000005a
            - |
              #
                  jne v1, exit_failure
                  ldai 0
                  return
              exit_failure:
                  ldai 1
                  return
            tags: ['tsan']
          - values: [u16, u16, 0, ucmp v1]
          - values: [u16, u16, 0x0000ffff, ucmp v1]
          - values: [u16, u16, 0x00005a5a, ucmp v1]
          - values:
            - i16
            - i16
            - 0
            - |
              #
                  jne v1, exit_failure
                  ldai 0
                  return
              exit_failure:
                  ldai 1
                  return
          - values:
            - i16
            - i16
            - 0xffffffff
            - |
              #
                  jne v1, exit_failure
                  ldai 0
                  return
              exit_failure:
                  ldai 1
                  return
          - values:
            - i16
            - i16
            - 0x00005a5a
            - |
              #
                  jne v1, exit_failure
                  ldai 0
                  return
              exit_failure:
                  ldai 1
                  return
          - values: [u32, u32, 0, ucmp v1]
          - values: [u32, u32, 0xffffffff, ucmp v1]
          - values: [u32, u32, 0x5a5a5a5a, ucmp v1]
          - values:
            - i32
            - i32
            - 0
            - |
              #
                  jne v1, exit_failure
                  ldai 0
                  return
              exit_failure:
                  ldai 1
                  return
          - values:
            - i32
            - i32
            - 0xffffffff
            - |
              #
                  jne v1, exit_failure
                  ldai 0
                  return
              exit_failure:
                  ldai 1
                  return
          - values:
            - i32
            - i32
            - 0x5a5a5a5a
            - |
              #
                  jne v1, exit_failure
                  ldai 0
                  return
              exit_failure:
                  ldai 1
                  return
            tags: ['tsan']


      - file-name: "check_int_64bit_types_p"
        isa:
          instructions:
            - sig: initobj.range method_id, v:in:none
              acc: out:ref
              format: [op_v_8_id_16]
        description: Check 'initobj.range' constructor behavior with primitive integer 64bit argument types in PandaAssembly context.
        header-template: []
        code-template: |
          .record Z {
              %s    f
          }
          .function void Z.ctor1(Z a0, u64 a1) <ctor> {
              return.void
          }
          .function void Z.ctor2(Z a0, %s a1) <ctor> {
              lda.64 a1
              stobj.64 a0, Z.f
              return.void
          }
          .function i32 main() {
              movi.64 v1, 0xffffffffffffffff
              initobj.range Z.ctor1, v1
              sta.obj v0
              ldobj.64 v0, Z.f
              movi.64 v1, 0
              %s
              jeqz chk2
              ldai 1
              return
          chk2:
              movi.64 v1, %s
              initobj.range Z.ctor2, v1
              sta.obj v0
              ldobj.64 v0, Z.f
              %s
              jeqz ok
              ldai 2
              return
          ok:
        check-type: exit-positive
        cases:
          - values: [u64, u64, ucmp.64 v1, 0, ucmp.64 v1]
          - values: [u64, u64, ucmp.64 v1, 0xffffffffffffffff, ucmp.64 v1]
          - values: [u64, u64, ucmp.64 v1, 0x5a5a5a5a5a5a5a5a, ucmp.64 v1]
            tags: ['tsan']
          - values: [i64, i64, ucmp.64 v1, 0, cmp.64 v1]
          - values: [i64, i64, ucmp.64 v1, 0xffffffffffffffff, cmp.64 v1]
          - values: [i64, i64, ucmp.64 v1, 0x5a5a5a5a5a5a5a5a, cmp.64 v1]


      - file-name: "check_float_types_p"
        isa:
          instructions:
            - sig: initobj.range method_id, v:in:none
              acc: out:ref
              format: [op_v_8_id_16]
        description: Check 'initobj.range' constructor behavior with primitive float argument types in PandaAssembly context.
        header-template: []
        code-template: |
          .record Z {
              f64    f
          }
          .function void Z.ctor1(Z a0, f64 a1) <ctor> {
              return.void
          }
          .function void Z.ctor2(Z a0, f64 a1) <ctor> {
              lda.64 a1
              stobj.64 a0, Z.f
              return.void
          }
          .function i32 main() {
              fmovi.64 v1, -1.0
              initobj.range Z.ctor1, v1
              sta.obj v0
              ldobj.64 v0, Z.f
              fmovi.64 v1, 0.0
              fcmpg.64 v1
              jeqz chk2
              ldai 1
              return
          chk2:
              fmovi.64 v1, %s
              initobj.range Z.ctor2, v1
              sta.obj v0
              ldobj.64 v0, Z.f
              fcmpg.64 v1
              jeqz ok
              ldai 2
              return
          ok:
        check-type: exit-positive
        cases:
          - values: [0.0]
          - values: [4.625]
          - values: [-4.625]
          - values: [0xfff0000000000000] # -Inf
          - values: [0x7ff0000000000000] # +Inf
            tags: ['tsan']
          - values: [0x7ff8000000000000]
          - values: [0x7ff8000000000010]
          - values: [0x7fffffffffffffff]
          - values: [0xffffffffffffffff]
            tags: ['tsan']

      - file-name: "check_float32_type_p"
        isa:
          instructions:
            - sig: initobj.range method_id, v:in:none
              acc: out:ref
              format: [op_v_8_id_16]
        description: Check 'initobj.range' constructor behavior with primitive float argument types in PandaAssembly context.
        header-template: []
        code-template: |
          .record Z {
              f32    f
          }
          .function void Z.ctor1(Z a0, f32 a1) <ctor> {
              return.void
          }
          .function void Z.ctor2(Z a0, f32 a1) <ctor> {
              lda.64 a1
              stobj a0, Z.f
              return.void
          }
          .function i32 main() {
              fmovi v1, -1.0
              initobj.range Z.ctor1, v1
              sta.obj v0
              ldobj v0, Z.f
              fmovi v1, 0.0
              fcmpg v1
              jeqz chk2
              ldai 1
              return
          chk2:
              fmovi v1, %s
              initobj.range Z.ctor2, v1
              sta.obj v0
              ldobj v0, Z.f
              fcmpg v1
              jeqz ok
              ldai 2
              return
          ok:
        check-type: exit-positive
        cases:
          - values: [0.0]
          - values: [4.625]
          - values: [-4.625]
          - values: [0xff800000] # -Inf
          - values: [0x7f800000] # +Inf
          - values: [0x7fc00000]
          - values: [0x7fc00010]
            tags: ['tsan']
          - values: [0x7fffffff]
          - values: [0xffffffff]

      - file-name: "check_obj_types_p"
        isa:
          instructions:
            - sig: initobj.range method_id, v:in:none
              acc: out:ref
              format: [op_v_8_id_16]
        description: Check 'initobj.range' constructor behavior with several object type arguments in PandaAssembly context.
        header-template: []
        code-template: |
          .record panda.Object <external>
          .record panda.Class <external>
          .record panda.String <external>
          .record Z {
              %s    f
          }
          .function void Z.ctor1(Z a0, Z a1) <ctor> {
              return.void
          }
          .function void Z.ctor2(Z a0, %s a1) <ctor> {
              lda.obj a1
              stobj.obj a0, Z.f
              return.void
          }
          .function i32 main() {
              mov.null v1
              initobj.range Z.ctor1, v1
              sta.obj v0
              ldobj.obj v0, Z.f
              jeqz.obj chk2
              ldai 1
              return
          chk2:
              %s
              sta.obj v1
              initobj.range Z.ctor2, v1
              sta.obj v0
              ldobj.obj v0, Z.f
              jeq.obj v1, ok
              ldai 2
              return
          ok:
        check-type: exit-positive
        cases:
          - values: [panda.String, panda.String, lda.str "test"]
          - values: [panda.Object, panda.String, lda.str "test"]
          - values: [panda.Class, panda.Class, lda.type Z]
          - values:
            - panda.Object
            - panda.Class
            - lda.type Z
            bugid: ["3594"]
            ignore: true
          - values: [panda.Object, panda.Object, "initobj.range Z.ctor1, v1"]
          - values: [panda.String, panda.String, lda.null]
            tags: ['tsan']
          - values:
            - "i32[]"
            - "i32[]"
            - |
              #
                  movi v7, 10
                  newarr v7, v7, i32[]
                  lda.obj v7
          - values:
            - "i64[]"
            - "i64[]"
            - |
              #
                  movi v7, 10
                  newarr v7, v7, i64[]
                  lda.obj v7
          - values:
            - "panda.String[]"
            - "panda.String[]"
            - |
              #
                  movi v7, 10
                  newarr v7, v7, panda.String[]
                  lda.obj v7
          - values:
            - Z[]
            - Z[]
            - |
              #
                  movi v7, 10
                  newarr v7, v7, Z[]
                  lda.obj v7
          - values:
            - panda.Object
            - u1[]
            - |
              #
                  movi v7, 10
                  newarr v7, v7, u1[]
                  lda.obj v7
          - values:
            - panda.Object
            - panda.Object[]
            - |
              #
                  movi v7, 10
                  newarr v7, v7, Z[]
                  lda.obj v7
            bugid: ['3608']
            ignore: true
          - values:
            - panda.Object[]
            - panda.Object[]
            - |
              #
                  movi v7, 10
                  newarr v7, v7, Z[][]
                  lda.obj v7
            bugid: ['3608']
            ignore: true


      - file-name: 'oome_p'
        isa:
          exceptions:
            - x_oom
        description: Create objects with 'initobj.range' instruction until OutOfMemoryError in PandaAssembly context
        header-template: []
        panda-options: "--heap-size-limit=67108864"
        bugid: ['3578', '4170', '4171']
        ignore: true
        code-template: |
          .record panda.OutOfMemoryError <external>
          .record Z {
          %s
          }
          .function void Z.ctor(Z a0, Z a1) <ctor> {
              return.void
          }
          .function i32 main() {
              movi v7, 50000   # array size
              newarr v6, v7, Z[]       # array ref
              movi v1, 0       # index
              mov.null v0      # null, dummy arg
          begin:
              initobj.range Z.ctor, v0
              starr.obj v6, v1
              inci v1, 1
              lda v1
              jlt v7, begin
          end:
              ldai 1 # Should not reach this line
              return

          catch_OOME:
              ldai 0 # Expected panda.OutOfMemoryError
              return

          catch_all:
              ldai 2 # Unexpected exception, test failed
              return

          .catch panda.OutOfMemoryError, begin, end, catch_OOME
          .catchall begin, end, catch_all
        check-type: none
        cases:
          - values:
            - "#{[*1..500].map do |i| \"    f64   f#{i}\\n\" end .join}"
            tags: ['tsan']


      - file-name: 'ame_p'
        isa:
          exceptions:
            - x_abstract
        description: Create objects with 'initobj.range' instruction with AbstractMethodError in PandaAssembly context
        header-template: []
        bugid: ['3625']
        code-template: |
          .record panda.AbstractMethodError <external>
          .record Z {}
          .function void Z.ctor1(Z a0, i32 a1) <ctor, noimpl>
          .function void Z.ctor2(Z a0, i32 a1, i32 a2) <ctor> {
              return.void
          }
          .function void Z.ctor3(Z a0, i32 a1, i32 a2, i32 a3) <ctor> {
              return.void
          }
          .function void Z.ctor4(Z a0, i32 a1, i32 a2, i32 a3, i32 a4) <ctor, noimpl>
          .function i32 main() {
          begin:
              %s
              initobj.range %s
          end:
              ldai 1 # Should not reach this line
              return

          catch_AME:
              ldai 0 # Expected panda.AbstractMethodError
              return

          catch_all:
              ldai 2 # Unexpected exception, test failed
              return

          .catch panda.AbstractMethodError, begin, end, catch_AME
          .catchall begin, end, catch_all
        check-type: none
        cases:
          - values:
            - movi v8, 800
            - Z.ctor1, v8
            tags: ['tsan']
          - values:
            - |
              #
                  movi v1, 10
                  movi v2, 20
                  movi v3, 30
                  movi v4, 40
            - Z.ctor4, v1


      - file-name: "regs_restored_p"
        isa:
          description: |
            Resolve class type from initializer method_id, allocate memory for an object, initialize its fields with their
            default values (i.e. 0 for primitives and null for objects), call specified initializer and put a reference to
            the newly created object into accumulator. method_id should resolve to an initializer.
        description: Check 'initobj.range' that registers are restored after the initializer call PandaAssembly context.
        tags: ['tsan']
        header-template: []
        code-template: |
          .record R {}
          .function void R.ctor(R a0, i16 a1, i32 a2, i16 a3, i32 a4, i32 a5, i32 a6, i32 a7, i32 a8, i32 a9, i32 a10) <ctor> {
              movi a1, -100
              movi a2, -200
              movi a3, -300
              movi a4, -400
              movi v0, 100
              movi v1, 200
              movi v2, 300
              movi v3, 400
              movi v4, 500
              movi v5, 600
              movi v6, 700
              movi v7, 800
              movi v8, 900
              movi v9, 1000
              movi v10, 1100
              movi v11, 1200
              movi v12, 1300
              movi v13, 1400
              movi v14, 1500
              movi v15, 1600
              return.void
          }
          .function i32 main() {
              movi v0, 1
              movi v1, 2
              movi v2, 3
              movi v3, 4
              movi v4, 5
              movi v5, 6
              movi v6, 7
              movi v7, 8
              movi v8, 9
              movi v9, 10
              movi v10, 11
              movi v11, 12
              movi v12, 13
              movi v13, 14
              movi v14, 15
              movi v15, 16
              initobj.range R.ctor, v0
              initobj.range R.ctor, v6
              ldai 1
              jeq v0, ok1
              return
          ok1:
              ldai 2
              jeq v1, ok2
              return
          ok2:
              ldai 3
              jeq v2, ok3
              return
          ok3:
              ldai 4
              jeq v3, ok4
              return
          ok4:
              ldai 5
              jeq v4, ok5
              return
          ok5:
              ldai 6
              jeq v5, ok6
              return
          ok6:
              ldai 7
              jeq v6, ok7
              return
          ok7:
              ldai 8
              jeq v7, ok8
              return
          ok8:
              ldai 9
              jeq v8, ok9
              return
          ok9:
              ldai 10
              jeq v9, ok10
              return
          ok10:
              ldai 11
              jeq v10, ok11
              return
          ok11:
              ldai 12
              jeq v11, ok12
              return
          ok12:
              ldai 13
              jeq v12, ok13
              return
          ok13:
              ldai 14
              jeq v13, ok14
              return
          ok14:
              ldai 15
              jeq v14, ok15
              return
          ok15:
              ldai 16
              jeq v15, ok16
              return
          ok16:
        check-type: exit-positive


      - file-name: "valid_static_initializer_p"
        isa:
          description: |
            Resolve class type from initializer method_id, allocate memory for an object, initialize its fields with their
            default values (i.e. 0 for primitives and null for objects), call specified initializer and put a reference to
            the newly created object into accumulator. method_id should resolve to an initializer.
        description: Check 'initobj.range' with static initializer in PandaAssembly context.
        tags: ['tsan']
        header-template: []
        code-template: |
          .record R {
            i32   cnt   <static>
          }
          .function void R.ctor(R a0, i32 a1) <ctor> {
              ldstatic R.cnt
              addi 1
              ststatic R.cnt
              return.void
          }
          .function void R.cctor() <cctor> {
              ldstatic R.cnt
              addi 1
              ststatic R.cnt
              return.void
          }
          .function i32 main() {
              movi v1, 0
              initobj.range R.ctor, v1
              initobj.range R.ctor, v1
              ldstatic R.cnt
              movi v0, 3
              jeq v0, ok
              ldai 20
              return
          ok:
        check-type: exit-positive


